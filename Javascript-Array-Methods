const myArr = ['Kobe', 'Jordan', 'Lebron', 'Magic'];

####### .forEach() written as for-loop
//when a .forEach() is called on an array, a callback function is invoked with the Item, 
//where the Index is found, and a copy of the Array 

//deconstructing a .forEach() function

function myForEach(myArr, callback) {
  for (let i = 0; i < myArr.length; i++) {
    callback(myArr[i], i, myArr)
  }
}

//These two are the same
console.log(myArr.forEach(console.log));   //.forEach()
console.log(myForEach(myArr, console.log));   //.myForEach()

#######  .map() written as for-loop
//deconstructing a .map() function

function myMap(myArr, callback) {
                // .map() returns new array, .forEach() does not
  const returnNewArr = [];
  for (let i = 0; i < myArr.length; i++) {
    const returnFromCallback = callback(myArr[i], i, myArr);
    returnNewArr.push(returnFromCallback)
  }
  return returnNewArr;
}

//These two are the same
console.log(myArr.map(console.log));
console.log(myMap(myArr, console.log));

******* .map() returns a new array, while .forEach() does not


########  .filter() written as for-loop

//deconstructing a .filter() function in ES6 way; return all items where index is > 1

const filterCallBack = (elem, index, array) => {
  if (index > 1) {
    return true;
  } else {
    return false;
  }
}

const myFilteredArray = myArr.filter(filterCallBack);
console.log(myArr);
console.log(myArr.filter(filterCallBack));

// deconstructing traditional .filter() function without using .filter, written in ES5 function way

function myFilter (myArr, callback) {
  const returnEmptyArr = [];
  for (let i = 0; i < myArr.length; i++) {
    if (i > 1) {
        returnEmptyArr.push(myArr[i]);
      }
    }
    return returnEmptyArr;
}

myFilter(myArr);

******TAKE AWAY, BOTH .map() and .filter() generate and return new arrays, 
*****while .forEach() just creates a for-loop on the same array


########  .reduce() written as a for-loop
// deconstructing .reduce()

let numArray = [0, 11, 23, 33, 45];

function myReduce(arr) {
  let counter = 0;
  for (let i = 0; i < arr.length; i++) {
    counter += arr[i];
    console.log(counter, arr[i], i, arr);     //optional parameters in a .reduce function SEE BELOW
  }
  return counter;
}

myReduce(numArray);


///// how .reduce() works  (parameters: accumulator (counter), currentValue (arr[i]), currentIndex (i), array (arr))

[0, 11, 23, 33, 45].reduce(function(accumulator, currentValue, currentIndex, array) {
  console.log(accumulator, currentValue, currentIndex, array);
  return accumulator + currentValue;
});

// TAKE-AWAY: Reduce doesn't return a new array, it returns the sum of all the values inside the array (optional, can return old array)

